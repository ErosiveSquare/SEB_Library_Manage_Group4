# 《软件工程B》知识点整理笔记-LJY

## 第一章 软件工程概述 (Overview)


### 1.1 软件危机 (Software Crisis)

- **定义**：在计算机软件的**开发**和**维护**过程中所遇到的一系列严重问题。
- 软件危机涉及：如何开发？如何维护？
- **四大典型表现**：
  1. **成本与进度失控**：超出预算，工期一拖再拖
  2. **质量低劣**：软件错误多，可靠性差，存在大量Bug。
  3. **维护困难**：代码可读性差，缺乏文档，维护成本甚至超过开发成本
  4. **供需矛盾**：软件生产率的提高远远跟不上硬件发展和用户需求的增长。



- **产生原因**：
  - **客观原因**：软件本身特点

    - 软件是逻辑部件，相对硬件重开发，生产只是复制，维护上也不同
    - 软件规模跨度大，复杂性随程序规模增加指数上升
    - 软件的分类广泛，按功能分为系统、支撑、应用软件

  - **主观原因**：软件开发与维护的方法不正确
    - 软件开发**无计划性**（成本和进度估计不足）

    - 软件需求不充分（用户、开发人员）

    - 软件**开发**过程没有统一、公认的**规范**

      例如：代码命名不规范、文档不规范性

    - 软件产品测试不充分、缺乏有效的项目管理、轻视软件维护



- **解决途径**：

  - **客观途径**：正确认识计算机软件

    - **软件 = 程序+数据+<u>文档</u>**

    - 程序：能完成预定功能和性能的可执行指令序列

      数据：使程序能适当地处理信息的数据结构

      文档：开发、使用和维护程序所需要的图文材料（面向管理、开发、维护、用户）



  - **主观途径**：软件工程

    - 采用**工程化**的概念、原理、技术和方法来开发与维护软件（即引入软件工程）。



### 1.2 软件工程 (Software Engineering)

- **IEEE定义**：将**系统化、规范化、可度量**的方法应用于软件的开发、运行和维护的过程。
- **软工三要素（方法学）**：法、器、道
  1. **开发方法 (Methods)**：完成软件开发任务的“技术手段”（如结构化方法、面向对象方法）。
  2. **软件工具 (Tools)**：为方法提供自动或半自动的支撑环境（如CASE工具、IDE）。
  3. **软件过程 (Process)**：为了获得高质量软件所需要完成的一系列任务的框架（即工作流程）。
- **软件工程管理**：
  1. **软件管理学**	2. **软件经济学** 3. **软件度量学**

### 1.3 软件过程模型 (Software Process Models)

又称生命周期模型，规定了软件开发各阶段的执行顺序。

#### 1. 瀑布模型 (Waterfall Model)

- **详细流程**：

  ![76723645520](C:\Users\Lenovo\AppData\Local\Temp\1767236455206.png)

- **详细说明**：

  **计划时期：**问题定义（目标与范围说明书）、可行性研究（可行性论证报告）、软件计划书

  **开发时期：**设计（需求分析+软件设计）+实现（编码+测试）

   - 需求分析：需求规格说明书（SRS）=软件功能需求+性能+环境与外部接口+约束

   - 软件设计：设计文档=总体设计{体系结构设计、数据设计、接口设计}+详细设计

     体系结构设计：系统架构图。数据设计：各表。详细设计：流程图

   - 编码：产生源代码

   - 测试：单元、集成、确认、系统测试

     产生测试报告：测试计划、测试用例、测试结果

  **运行时期**：产生维护报告

- **特点**：

  - **顺序性和依赖性**：前一阶段完成后才能进入下一阶段。
  - **文档驱动**：每个阶段必须产出合格的文档，具有**质量保证**。
  - **推迟实现**：区分逻辑设计与物理设计尽可能推迟程序物理实现

- **缺点**：
  - **僵化、理想化**：难以适应**需求的变化**；试用前用户只从文档了解产品，无法提出确切需求
  - **基于准确需求的假设**：只有分析员作出准确需求分析时，才能得到预期的正确结果

- **适用**：`软件需求明确，需求反复性小，开发技术成熟的场合`

#### 2. 快速原型模型 (Rapid Prototyping)

- **核心**：快速构建一个可运行的“原型”系统给用户试用，以**获取和确认真实需求**。

  ![76723647430](C:\Users\Lenovo\AppData\Local\Temp\1767236474300.png)

- **分类**：
  - **抛弃型原型**：原型仅用于探索需求，用完即扔（常用）。
  - **进化型原型**：在原型基础上不断完善，直至成为最终产品。

- **优点**：用户参与度高，能有效解决需求模糊问题。

- **问题**：

  - 用户可能误解原型的角色
  - 缺少控制：用户可能不断提新要求，原型迭代周期难控制。
  - 额外的花费：原型开发、不合适技术、与用户老接触麻烦

- **适用**：**需求模糊**、动态变化的项目。

#### 软件演化模型（Evolutionary Model）举例3-4：

利用迭代思想，渐进地开发逐步完善的软件版本（增量、螺旋）

#### 3. 增量模型 (Incremental Model)

- **核心**：将软件产品划分多个增量（构件），各次迭代中，每次做一个增量。

  ![76723651027](C:\Users\Lenovo\AppData\Local\Temp\1767236510272.png)

- **优点**：

  - 分批逐步提交产品，短时间内提交部分功能产品
  - 逐步增加产品功能，用户有时间学习适应新产品

- **缺点**：

  - 构件集成问题－>软件体系结构必须是开放的

  - 增量模型自身的矛盾性

    软件应看作一个整体 <－> 软件又是构件序列，构件间相互独立

#### 4. 螺旋模型 (Spiral Model)

- **核心**：= 瀑布模型 + 快速原型 + **风险分析**。
- **流程**：沿着螺旋线旋转，每一圈包括四个步骤（制定计划 $\to​$ 风险分析 $\to​$ 实施工程 $\to​$ 客户评估）。
- **适用**：**大型、高风险**、复杂的系统（如航空航天、操作系统）, 主要适用于内部大型开发.

#### 5. 迭代模型 

- **增量模型**：逐步增加功能直到构造全部功能
- **迭代模型**：一开始提交完整系统，后续补充完善各子系统

![76723652464](C:\Users\Lenovo\AppData\Local\Temp\1767236524642.png)

#### 6. 面向对象开发模型 

#### 6. 1 喷泉模型 

![76723654409](C:\Users\Lenovo\AppData\Local\Temp\1767236544096.png)

#### 6.2基于构件的软件开发（CBD）

- **软件复用**：将已有软件成分用于构造新系统——“开发伴随复用，开发为了复用”

- **构件**：可以复用，相对独立的部件

- **CBD**：利用预先封装好的软件来构造应用

  ![76723658638](C:\Users\Lenovo\AppData\Local\Temp\1767236586381.png)

#### 7. 敏捷开发

- **价值观**：个体和交互 > 流程和工具；可工作的软件 > 详尽的文档；客户协作 > 合同谈判；**响应变化** > 遵循计划。
- **代表方法一：RUP **
  - **核心实践 (6条)**：
    - **迭代开发**
    - **需求管理 (TDD)**
    - **基于构件的架构 (CI)**
    - **可视化建模UML**
    - **持续的质量验证**
    - **变更管理**


- **代表方法二：XP (极限编程)**
  - **核心实践 (12条)**：
    - **结对编程 (Pair Programming)**：两人一台电脑，一人写一人看，实时复审。
    - **测试驱动开发 (TDD)**：先写测试代码，再写业务代码。
    - **持续集成 (CI)**：频繁合并代码。
    - **现场客户**：客户时刻在现场解决疑问。
    - 其他：简单设计、重构、集体代码所有权等。




- **代表方法三：Scrum**
  - **3个角色**：
    - **Product Owner (PO)**：产品负责人，定需求，排优先级（维护Product Backlog）。
    - **Scrum Master (SM)**：敏捷教练，服务团队，清除障碍。
    - **Team**：开发团队，自组织。
  - **3个产出物**：
    - **Product Backlog**：产品待办事项列表（需求池）。
    - **Sprint Backlog**：冲刺待办事项列表（本周期要做的事）。
    - **Increment**：可交付的软件增量。
  - **4个会议**：Sprint计划会、每日站会（Daily Scrum）、Sprint评审会（Demo）、Sprint回顾会（总结改进）。


------

## 第二章 软件项目计划

问题定义、可行性研究、项目实施计划

### 2.1 概述

- **一个软件是否值得开发**：需要多少成本？存在何风险去预防？**可行性分析报告**
- **如何制定计划，安排分配？**：**项目计划**

### 2.2 问题定义

- **目的**：弄清系统总目标、项目所需的资源与经费（粗略估计）
- **任务**：编写**“系统目标与范围说明书”**

![76723224621](C:\Users\Lenovo\AppData\Local\Temp\1767232246212.png)

### 2.2可行性研究

研究项目是否**可能实现**与**值得实现**

推陈出新→ 几套方案备选（评价、择一）→ 可行性分析(经济、技术、法律、用户使用)

#### STAG1：推陈出新 → 使用**系统流程图**

根据“系统目标范围说明”描述系统物理模型，表达数据流动情况（DFD简化版）
包含人员、硬件、软件等子系统

#### STAG2：推荐方案，方案选择

不同方案的**系统功能和性能**、**成本人员设备要求**等都不同，需要反复比较再选择。

#### STAG3：可行性分析的内容

##### 经济可行性：通过**“成本-效益分析”**来看投资-回报期

##### 经济可行性-成本估计：

- **1.系统成本的组成：** 软硬件+系统开发费用+人员培训+系统安装维护费

- **2.基于代码行成本估计**：

  ![76723670939](C:\Users\Lenovo\AppData\Local\Temp\1767236709395.png)

    **$$L = \frac{a + 4 \times m + b}{6}$$**

   `其中a为乐观行数、m平均、b悲观`

  `  用户接口控制成本  2300行×10元/行=2.3万元`
  `  用户接口控制工作量 2300行/950行/人月=2.4人月`


- **3.基于工作量的成本分析**

  ![76723424873](C:\Users\Lenovo\AppData\Local\Temp\1767234248735.png)

 ##### 经济可行性-效益分析：

- 系统效益：经济效益（有形货币）+社会效益（无形）

- 一般设**软件生命周期**为**5年**

- 1. **货币的时间价值**

  - 现存P元，年利率i%，则n年后价值为：$F = P(1+i)^n$

  - 若n年后能收入F，则折合现在价值为：$P = F/(1+i)^n$

  ![76723522213](C:\Users\Lenovo\AppData\Local\Temp\1767235222139.png)



- 2. **纯收入**

  - 指**生存周期内**经济效益折合成**现在值**与**投资**之差(**净现值**)

  上例中为:41.5630 - 20 = 21.563

  若每年的净现金流量都相等（CF₁ = CF₂ = ... = CFₙ = A）
  $NPV = -I + \sum_{t=1}^{n} \frac{A}{(1 + i)^t}$可简化为：$\boxed{NPV = -I + A \times \frac{1 - (1+i)^{-n}}{i}}$



- 3. **投资回报期**

  - 累计经济效益 == 最初投资 的时间

  ![76723594760](C:\Users\Lenovo\AppData\Local\Temp\1767235947606.png)

  ![76723599301](C:\Users\Lenovo\AppData\Local\Temp\1767235993011.png)

### 2.3项目实施计划

- 人员安排
- *任务安排（甘特图、工程网络图）**老师上课说不考**

------

## 第三章 软件需求分析 

本章重点：结构化分析的三大模型（DFD、DD、ER图），面向对象UML的图（用例图、类图、顺序图）。

### 3.1 需求分析概述

#### 3.1.1 需求分析的任务/步骤

让用户与开发者共同明确将要开发的是什么样的系统

- **步骤**：获取需求→提炼：建立分析模型→描述：写SRS→验证

#### 3.1.2 需求获取的常用方法

收集资料、联合分析小组、客户访谈&会议、实地考察【看用户怎么操作】、快速原型法

#### 3.1.3需求说明

- **功能需求**

  分析用户要求实现的全部功能（分析建模DFD，DD）

- **性能需求**

  时间特性、时间精确性（相应、更新、数据转换时间）、存储容量、安全

- **外部接口需求**

  (1) 用户接口（人机界面）（2）硬件接口

  (3) 软件接口              （4）通信接口

- **属性**（可靠性、可用性、可维护性...）

- **约束**（精度、标准、语言、硬件平台...）

### 3.2 结构化分析方法 (SA)

**核心思想**：自顶向下，逐步细化。**面向数据（适于数据处理类软件需求分析）**。

- **步骤：**
  - 自顶向下功能分解，画**分层DFD**
  - 自后向前定义系统的数据
  - 绘制DD和PSPEC（加工说明，好像没讲过）
  - 写出SRS

#### 1. 数据流图 (DFD)

描绘信息在系统中的流动和变换。

- **四大基本符号**：
  - **加工**：圆圈或圆角矩形。表示对数据的处理（动词+名词，如“计算工资”）。
  - **数据流**：箭头。表示数据的流动方向。
  - **数据存储**：双横线或开口矩形。表示静态存储的数据（文件、数据库表）。
  - **外部实体**：竖矩形。表示系统之外的人、组织或外部系统（数据的源点或终点）。

- **建模步骤**：
  1. 画**顶层图**：仅一个加工（代表整个系统），画出所有输入输出流和外部实体。
  2. 画**0层图**：将系统分解为几个主要功能。
  3. 画**子图**：对复杂加工继续逐层分解。

- **重要原则**：

  1. 每个**加工**必须有**输入输出**流

  2. 每个**数据流**必须有一个**合适的名字**

  3. **数据守恒（数据不能是无根之水）**

     加工的输出数据必须能从输入数据推导出来（不能无中生有）。

  4. **分解中的父子平衡（父图和子图的平衡）**

     父图中某个加工的输入输出流，必须与子图中的输入输出流完全对应。

  5. **文件的使用：**局部文件（文件要有读有写，以防止遗漏丢失


  6. **注意分解速度**
     - 最多不要超过**7个**，上层快些，下层慢些
     - 当每个加工都已足够简单时，分解就可结束

#### 2. 数据字典 (DD - Data Dictionary)

- **定义**：对DFD中出现的**所有**数据元素、数据流、数据存储进行严格的定义。是分析模型的核心。
- **定义符号**：
  - `=` ：定义为 (is composed of)
  - `+` ：与/和 (and)
  - `[ ... | ... ]` ：或 (or)，多选一
  - `{ ... }` ：重复 (iteration)
  - `( ... )` ：可选 (optional)
- **示例**：`学生记录 = 学号 + 姓名 + { 选课信息 } + ( 备注 )`

#### 3. E-R 图 (Entity-Relationship Diagram)

用于描述**数据对象**及其关系。

- **实体** (矩形)：客观存在的事物（如：学生）。
- **属性** (椭圆)：实体的特征（如：学号）。
- **关系** (菱形)：实体间的联系（如：选修）。
  - 类型：1:1, 1:N, M:N。

### 3.3 基于UML的面向对象分析 **（老师说基本不用看）**

**UML**：统一建模语言，标准化的图形符号。

#### 1. 用例图 (Use Case Diagram)

描述系统的**功能需求**（用户视角）。

- **参与者 (Actor)**：小人图标。使用系统的人或外部系统。
- **用例 (Use Case)**：椭圆图标。系统提供的一个功能单元。
- **关系**：
  - **关联 (Association)**：实线。Actor与Use Case的交互。
  - **包含 (include)**：虚线箭头。基础用例**必须**调用包含用例（通常是为了提取公共功能，如“登录”）。
  - **扩展 (extend)**：虚线箭头。在特定条件下才执行的扩展功能。
  - **泛化**：继承关系。

#### 2. 类图 (Class Diagram)

描述系统的**静态结构**。

- **类 (Class)**：三层矩形框（类名、属性、操作）。
- **关系（强弱顺序）**：
  - **依赖 (Dependency)**：虚线箭头。A“使用”B（如B作为A的方法参数）。关系最弱。
  - **关联 (Association)**：实线。A与B有关联（拥有）。
  - **聚合 (Aggregation)**：空心菱形。**整体与部分**的关系（弱拥有），部分可以脱离整体存在（如：汽车与轮胎）。
  - **组合 (Composition)**：实心菱形。**整体与部分**的关系（强拥有），生命周期一致，整体亡则部分亡（如：人与大脑）。
  - **泛化 (Generalization)**：空心三角实线。**继承**关系（Is-a）。

#### 3. 交互图 (Interaction Diagrams)

- **顺序图 (Sequence Diagram)**：
  - 强调消息的**时间顺序**。
  - **生命线**（垂直虚线）、**激活条**（细长矩形）、**消息**（实线箭头调用，虚线箭头返回）。
- **通信图 (Communication Diagram)**：强调对象之间
- 的**连接结构**。

------

## 第四章 软件设计概述 (Software Design)

**需求分析：**对目标系统的数据、功能和行为建模；**设计：**把分析阶段的需求说明转换成设计文档。

### 4.1 软件设计的阶段和任务

- **概要设计 (总体设计)**：
  - 总体结构设计（系统分多少模块，层次结构）。
  - 接口设计。
  - 数据设计（数据库表结构）。
- **详细设计 (过程设计)**：
  - 设计每个模块内部的算法、数据结构。

### 4.2 软件设计的基本概念

1. **模块与构件**：
   - 模块：定义输入、输出和特性的程序实体
   - 构件：可重复使用的软件组件
2. **抽象与细化**：
   - 抽象：分层次考虑和处理问题(数据和过程)
   - 细化：从高到低的逐步分解过程
3. **软件复用**：充分利用已有的现成构件，不必一切从头开始
4. **信息隐藏**：模块内部的数据和过程对外部不可见，仅通过接口交互。**这是实现高内聚低耦合的基础。**

### 4.3 模块化设计

- 模块化设计：大型软件分成一个个小的相互独立又相互联系的模块

- 每个模块完成一个子功能

- 集成起来构成一个整体

- ![76728183471](C:\Users\Lenovo\AppData\Local\Temp\1767281834717.png)

- 模块独立性——模块分解所必须遵循的准则

  - 设计软件结构时，每个模块具有一个相对独立的子功能
  - 且与其他模块没有过多联系

- 模块独立性的度量:

  **内聚**（cohesion）——模块**内部**各成分之间的联系

  **耦合**（coupling）——模块**与其它**模块间的联系

- 模块的独立性高 ：**高内聚，低耦合**——块内联系强 块间联系弱

#### 1. 内聚 (Cohesion) - 越高越好

衡量模块内部各元素结合的紧密程度(从低到高排序)：

1. **偶然内聚 (Coincidental)**：元素间没有任何联系，只是凑巧放在一起。**[最差]低**
2. **逻辑内聚 (Logical)**：完成一组逻辑上相关的功能（如“输入所有类型数据”），通过参数选择执行哪一个。**低**
3. **时间内聚 (Temporal)**：因为在同一时间段执行而放在一起（如“系统初始化”模块）。**低**
4. **过程内聚 (Procedural)**：元素按特定次序执行。**中**
5. **通信内聚 (Communicational)**：操作**同一个数据结构**或输入/输出。**中**
6. **顺序内聚 (Sequential)**：上一个元素的输出是下一个元素的输入（流水线）。**高**
7. **功能内聚 (Functional)**：模块内所有元素共同完成**一个单一的、明确的功能**（如“计算平方根”）。**[最好]高**

#### 2. 耦合 (Coupling) - 越低越好

衡量模块之间联系的紧密程度。

(从好到坏排序)：

1. **非直接耦合 (No Direct)**：模块间无直接联系（通过主控模块调用）。**[最好]弱**
2. **数据耦合 (Data)**：模块间仅传递**简单数据值**（如 int, char）。**[推荐]弱**
3. **标记/特征耦合 (Stamp)**：传递**整个数据结构**（如 Struct, Object），但被调用模块只用了其中一部分数据。**弱**
4. **控制耦合 (Control)**：一个模块传递**控制信号**（如开关、标志位 flag）给另一个模块，从而控制其执行逻辑。**[应尽量避免]中**
5. **外部耦合**：与外部环境（如I/O设备）关联。**较强**
6. **公共环境耦合 (Common)**：多个模块共享**全局变量**或公共区域。**较强**
7. **内容耦合 (Content)**：一个模块**直接修改**另一个模块的内部数据或代码（跳转）。**最强**

------

## 第五章 软件设计方法

本章重点：如何将DFD转换为软件结构图（SC），人机交互设计的黄金原则和细节。

### 5.1 概述

#### 5.1.1 传统的设计方法包括：

**(1)面向数据流设计（SD方法）**

- 数据流是考虑一切问题的出发点，SA→SD；
- 集中精力在模块的划分上，以得出软件的体系结构图；
- 适合于在概要设计阶段使用。

**(2)面向数据设计（Jackson方法）**

- 数据结构→算法→程序结构；
- 最终得出程序的过程性描述，并不明确软件现分几个模块的概念；


- 适合于在过程设计阶段使用。

#### 5.1.2 结构化设计模型——从分析模型导出设计模型
![76732297324](C:\Users\Lenovo\AppData\Local\Temp\1767322973243.png)

### 5.2 结构化设计SD (Structured Design)

将分析阶段的**数据流图 (DFD)** 映射为设计阶段的**结构图 (SC图)（总体结构设计、接口设计）**。

![76741665792](C:\Users\Lenovo\AppData\Local\Temp\1767416657925.png)

### 5.3 SC图如何设计：

- **用SD方法从DFD图$\to$SC软件结构图**

  1. 精化DFD图


  2. 确定DFD的类型:变换流？事务流？


  3. 划定流的边界


  4. 把DFD图映射为程序结构（初始的SC图 ）

     **变换映射**或**事务映射**

  5.优化初始的SC图：通过设计复审和启发式策略

#### DFD类型1：变换流

- **特征**：数据呈线性流动：**输入 $\to$ 变换中心(处理) $\to$ 输出**。
- **设计步骤**：
  1. 确定输入流、变换中心、输出流的边界。
  2. 设计顶层控制模块（主模块）。
  3. 为输入、变换、输出各设计一个中层控制模块。
  4. 下沉到底层具体的功能模块。

#### DFD类型2：事务流

- **特征**：数据流向呈现**辐射状**。根据输入数据的类型（事务），从多条路径中**选择**一条执行。
- **设计步骤**：
  1. 识别事务中心（调度模块）。
  2. 将事务中心映射为调度模块。
  3. 为每种具体的事务类型设计一个处理模块（及下属模块）。

![76732371766](C:\Users\Lenovo\AppData\Local\Temp\1767323717665.png)

#### 变换映射

**建立初始SC图的框架** 

- 顶层都只含一个用于控制的主模块
- 第一层包括传入、传出和变换中心三个模块

**分解SC图的各个分支** 

- 分解实质上是“映射”

#### 这PPT弄的是个啥

![76741671107](C:\Users\Lenovo\AppData\Local\Temp\1767416711073.png)

### 5.4 数据和文件设计

![76741679813](C:\Users\Lenovo\AppData\Local\Temp\1767416798132.png)

![76741687210](C:\Users\Lenovo\AppData\Local\Temp\1767416872103.png)

![76741688893](C:\Users\Lenovo\AppData\Local\Temp\1767416888937.png)

![76741690133](C:\Users\Lenovo\AppData\Local\Temp\1767416901334.png)

NS图、IPO图、流程图、活动图

### 5.6 界面设计

实用性出发

#### 5.6.1. 黄金原则

1. **置用户于控制之下（以人为本）**：
   - 考虑`用户的分级、特点`
   - 提供帮助tips、help
   - 提供有效的反馈（进度条、"输入有误"、正在...中）
2. **减少用户的记忆负担**：
   - **菜单人性化**

     - 每层的命令个数遵循7+2
     - 面向不同用户，按逻辑进行分组
     - 命令层次<=3层：鼠标点击次数少
     - 使用最频繁的命令放在前、后面
   - **减少不必要的输入**

     - 能读就不再重复输入
     - 提供热键、常用功能的TOOlBar
     - 能选的不输入
     - 必要的输入检查


3. **保持界面一致性 (Make the interface consistent)**：
   - 风格一致（菜单、对话框、按钮）
   - 前景背景反差
   - 简约不要太花哨
4. **容错与错误处理**：操作提供容错性（撤销）、防止灾难性错误、错误提示

#### 5.6.2 设计输入输出

##### 5.6.2.1 设计输入

- **确定输入设备**

  根据问题域，选取恰当的输入设备

- **设计输入界面**

  - **菜单设计**：
    - **类型**：固定位置菜单（顶、侧、底）、下拉菜单、弹出式菜单。
    - **原则**：风格一致简洁；深度不宜过深（ **$\le$ 3层**）；按逻辑分组、面向不同用户分组。
  - **对话框设计**：
    - **布局**：按逻辑分组组织输入框（如“个人信息”组、“联系方式”组）。
    - **输入控件**：可选、必选、下拉、组合框、文本框
  - **对话框的输入检查 (Input Validation)**：必须在数据进入系统前拦截错误。
    - **数据有效性**：范围、位数控制、字符有效性、删除前导空格
    - **组合控制**：检查多输入框之间的逻辑关系（如“结束日期”必须晚于“开始日期”）。
    - **输入框组合完备性**：必填的都填了么？
    - **其他**：现在不用的文本框/按钮的变灰、尽可能自动输入...
  - **窗口布局：**划分几个功能区域、风格一致

##### 5.6.2.1 设计输出

- **确定输出设备** 

  根据问题域，选取恰当的输出设备

- **设计输出内容**

  - 输出设计中强调界面的布局设计


  - 多种显示方式的选择等


## 第七章 软件测试

### 7.1 测试的基本概念

#### 7.1.1 测试的目的与任务

目的：发现程序中错误，任务：为找错误运行程序，暴露程序中错误

纠错：消除

#### 7.1.2 测试用例Test Case

一次程序执行需要的测试数据，一个case一个结果

#### 7.1.3 测试的特性

1.挑剔性	2.复杂性	3.不彻底性（不能穷尽）

#### 7.1.4 测试的原则

 ##### 原则1：Pareto 80/20原则

- **常用**功能占全部功能**20%**


- 用户**80%时间**在用这**20%**


- 测试发现的**错误80%**都**在这20%**程序中

##### 原则2：测试应尽早进行

#### 7.1.5 测试的步骤

- 1. **单元测试**
     - 测试每个模块（算法、接口）
     - 保证每个模块运行正确
  2. **集成测试**
     - 测试软件的总体结构，主要是模块中接口
     - 参照概要设计
  3. **确认测试**
     - 软件是否满足需求
  4. **系统测试**
     - 检查软件与系统中的硬件、其他软件系统、人员等是否协调工作

### 7.2 测试技术**（只考到黑盒）**

#### 7.2.1 黑盒测试技术

也叫**功能测试**，不考虑内部结构与处理过程

##### 等价分类法

- **思想：**

  - 把输入数据可能值分为若干等价类
  - 每类中任一测试用例，都能代表其等价类中其他用例

- **优点：**

  漫无边际的随机测试$ \to $有针对性的有效等价类

- **方法：**

  - 若干**有效等价类**同用**一个**测试用例
  - **每个无效等价类**设计**一个**测试用例

- **例子：**

  ![76740571691](C:\Users\Lenovo\AppData\Local\Temp\1767405716913.png)

- **等价类的划分的经验：**

  ![76740579624](C:\Users\Lenovo\AppData\Local\Temp\1767405796242.png)

##### 边界值分析法

- 选择使被测程序能在边界值附近运行的用例，刚好=、>、<边界值的数据


- 例子:

  ![76740629474](C:\Users\Lenovo\AppData\Local\Temp\1767406294747.png)

- **边界值的划分经验**：

  ![76740639017](C:\Users\Lenovo\AppData\Local\Temp\1767406390176.png)

##### 猜错法

猜测在哪些地方容易出错，设计测试用例

**一般先用等价类法和边界法设计测试用例，用猜错法补充**
